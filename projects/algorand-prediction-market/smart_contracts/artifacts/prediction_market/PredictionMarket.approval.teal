#pragma version 10
#pragma typetrack false

// smart_contracts.prediction_market.contract.PredictionMarket.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 8 3
    bytecblock "market_counter" "total_pool" 0x151f7c75 "market_title" "creator" 0x0000000000000000
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/prediction_market/contract.py:8-9
    // # Global state
    // self.market_counter = UInt64(0)
    bytec_0 // "market_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/prediction_market/contract.py:10
    // self.market_title = String("")
    bytec_3 // "market_title"
    pushbytes ""
    app_global_put
    // smart_contracts/prediction_market/contract.py:11
    // self.total_pool = UInt64(0)
    bytec_1 // "total_pool"
    intc_0 // 0
    app_global_put
    // smart_contracts/prediction_market/contract.py:12
    // self.creator = Txn.sender
    bytec 4 // "creator"
    txn Sender
    app_global_put

main_after_if_else@2:
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@12
    pushbytess 0xcb3b9c04 0x9c1dbe67 0xd2ab8a70 0xe35cc11c 0xd7a2d755 0x40314e7c 0x7250a940 // method "create_market(string,string[],uint64[],uint64)uint64", method "place_bet(uint64,uint64,pay)void", method "settle_market(uint64,uint64)void", method "claim_winnings(uint64)uint64", method "get_market_info(uint64)(string,string[],uint64[],uint64[],uint64,uint64,uint64,uint64)", method "get_user_position(uint64,address)(uint64[],uint64,bool)", method "get_market_count()uint64"
    txna ApplicationArgs 0
    match main_create_market_route@5 main_place_bet_route@6 main_settle_market_route@7 main_claim_winnings_route@8 main_get_market_info_route@9 main_get_user_position_route@10 main_get_market_count_route@11

main_after_if_else@14:
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    intc_0 // 0
    return

main_get_market_count_route@11:
    // smart_contracts/prediction_market/contract.py:143
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_market_count
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_user_position_route@10:
    // smart_contracts/prediction_market/contract.py:121
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/prediction_market/contract.py:121
    // @arc4.abimethod(readonly=True)
    callsub get_user_position
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_market_info_route@9:
    // smart_contracts/prediction_market/contract.py:77
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/prediction_market/contract.py:77
    // @arc4.abimethod(readonly=True)
    callsub get_market_info
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_claim_winnings_route@8:
    // smart_contracts/prediction_market/contract.py:67
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/prediction_market/contract.py:67
    // @arc4.abimethod
    callsub claim_winnings
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_settle_market_route@7:
    // smart_contracts/prediction_market/contract.py:59
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/prediction_market/contract.py:59
    // @arc4.abimethod
    callsub settle_market
    intc_1 // 1
    return

main_place_bet_route@6:
    // smart_contracts/prediction_market/contract.py:39
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/prediction_market/contract.py:39
    // @arc4.abimethod
    callsub place_bet
    intc_1 // 1
    return

main_create_market_route@5:
    // smart_contracts/prediction_market/contract.py:14
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/prediction_market/contract.py:14
    // @arc4.abimethod
    callsub create_market
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@12:
    // smart_contracts/prediction_market/contract.py:4
    // class PredictionMarket(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@14
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.prediction_market.contract.PredictionMarket.create_market(title: bytes, options: bytes, odds: bytes, duration_hours: bytes) -> bytes:
create_market:
    // smart_contracts/prediction_market/contract.py:14-21
    // @arc4.abimethod
    // def create_market(
    //     self,
    //     title: arc4.String,
    //     options: arc4.DynamicArray[arc4.String],
    //     odds: arc4.DynamicArray[arc4.UInt64],
    //     duration_hours: arc4.UInt64
    // ) -> arc4.UInt64:
    proto 4 1
    // smart_contracts/prediction_market/contract.py:23-24
    // # Basic validation
    // assert options.length >= 2, "Market must have at least 2 options"
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dupn 2
    pushint 2 // 2
    >=
    assert // Market must have at least 2 options
    // smart_contracts/prediction_market/contract.py:25
    // assert options.length == odds.length, "Options and odds must have same length"
    frame_dig -2
    intc_0 // 0
    extract_uint16
    ==
    assert // Options and odds must have same length
    // smart_contracts/prediction_market/contract.py:27-28
    // # Validate odds (minimum 101 = 1.01x)
    // for i in urange(options.length):
    intc_0 // 0

create_market_for_header@1:
    // smart_contracts/prediction_market/contract.py:27-28
    // # Validate odds (minimum 101 = 1.01x)
    // for i in urange(options.length):
    frame_dig 1
    frame_dig 0
    <
    bz create_market_after_for@4
    // smart_contracts/prediction_market/contract.py:29
    // assert odds[i] >= 101, "Odds must be at least 1.01 (101)"
    frame_dig -2
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    pushbytes 0x0000000000000065
    b>=
    assert // Odds must be at least 1.01 (101)
    // smart_contracts/prediction_market/contract.py:27-28
    // # Validate odds (minimum 101 = 1.01x)
    // for i in urange(options.length):
    intc_1 // 1
    +
    frame_bury 1
    b create_market_for_header@1

create_market_after_for@4:
    // smart_contracts/prediction_market/contract.py:31-32
    // # Increment market counter and store basic market info
    // self.market_counter += UInt64(1)
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    intc_1 // 1
    +
    bytec_0 // "market_counter"
    swap
    app_global_put
    // smart_contracts/prediction_market/contract.py:33
    // self.market_title = title.native
    frame_dig -4
    extract 2 0
    bytec_3 // "market_title"
    swap
    app_global_put
    // smart_contracts/prediction_market/contract.py:34
    // self.total_pool = UInt64(0)
    bytec_1 // "total_pool"
    intc_0 // 0
    app_global_put
    // smart_contracts/prediction_market/contract.py:35
    // self.creator = Txn.sender
    bytec 4 // "creator"
    txn Sender
    app_global_put
    // smart_contracts/prediction_market/contract.py:37
    // return arc4.UInt64(self.market_counter)
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    itob
    frame_bury 0
    retsub


// smart_contracts.prediction_market.contract.PredictionMarket.place_bet(market_id: bytes, option_index: bytes, payment_txn: uint64) -> void:
place_bet:
    // smart_contracts/prediction_market/contract.py:39-45
    // @arc4.abimethod
    // def place_bet(
    //     self,
    //     market_id: arc4.UInt64,
    //     option_index: arc4.UInt64,
    //     payment_txn: gtxn.PaymentTransaction
    // ) -> None:
    proto 3 0
    // smart_contracts/prediction_market/contract.py:47-48
    // # Basic validation
    // assert market_id.native <= self.market_counter, "Market does not exist"
    frame_dig -3
    btoi
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    <=
    assert // Market does not exist
    // smart_contracts/prediction_market/contract.py:49
    // assert option_index.native < 3, "Invalid option index"  # Simplified to 3 options max
    frame_dig -2
    btoi
    intc_3 // 3
    <
    assert // Invalid option index
    // smart_contracts/prediction_market/contract.py:51-52
    // # Validate payment transaction
    // assert payment_txn.receiver == Global.current_application_address, "Payment must be to application"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be to application
    // smart_contracts/prediction_market/contract.py:53
    // assert payment_txn.amount >= 1_000_000, "Minimum bet is 1 ALGO"
    frame_dig -1
    gtxns Amount
    dup
    pushint 1000000 // 1000000
    >=
    assert // Minimum bet is 1 ALGO
    // smart_contracts/prediction_market/contract.py:54
    // assert payment_txn.sender == Txn.sender, "Payment sender must match transaction sender"
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender must match transaction sender
    // smart_contracts/prediction_market/contract.py:56-57
    // # Update total pool
    // self.total_pool += payment_txn.amount
    intc_0 // 0
    bytec_1 // "total_pool"
    app_global_get_ex
    assert // check self.total_pool exists
    +
    bytec_1 // "total_pool"
    swap
    app_global_put
    retsub


// smart_contracts.prediction_market.contract.PredictionMarket.settle_market(market_id: bytes, winning_option: bytes) -> void:
settle_market:
    // smart_contracts/prediction_market/contract.py:59-60
    // @arc4.abimethod
    // def settle_market(self, market_id: arc4.UInt64, winning_option: arc4.UInt64) -> None:
    proto 2 0
    // smart_contracts/prediction_market/contract.py:62-63
    // # Only creator can settle
    // assert Txn.sender == self.creator, "Only market creator can settle"
    txn Sender
    intc_0 // 0
    bytec 4 // "creator"
    app_global_get_ex
    assert // check self.creator exists
    ==
    assert // Only market creator can settle
    // smart_contracts/prediction_market/contract.py:64
    // assert market_id.native <= self.market_counter, "Market does not exist"
    frame_dig -2
    btoi
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    <=
    assert // Market does not exist
    // smart_contracts/prediction_market/contract.py:65
    // assert winning_option.native < 3, "Invalid winning option"
    frame_dig -1
    btoi
    intc_3 // 3
    <
    assert // Invalid winning option
    retsub


// smart_contracts.prediction_market.contract.PredictionMarket.claim_winnings(market_id: bytes) -> bytes:
claim_winnings:
    // smart_contracts/prediction_market/contract.py:67-68
    // @arc4.abimethod
    // def claim_winnings(self, market_id: arc4.UInt64) -> arc4.UInt64:
    proto 1 1
    // smart_contracts/prediction_market/contract.py:70
    // assert market_id.native <= self.market_counter, "Market does not exist"
    frame_dig -1
    btoi
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    <=
    assert // Market does not exist
    // smart_contracts/prediction_market/contract.py:72-73
    // # Simplified payout - return 90% of total pool to claimant
    // payout = self.total_pool * UInt64(90) // UInt64(100)
    intc_0 // 0
    bytec_1 // "total_pool"
    app_global_get_ex
    assert // check self.total_pool exists
    pushint 90 // 90
    *
    pushint 100 // 100
    /
    // smart_contracts/prediction_market/contract.py:75
    // return arc4.UInt64(payout)
    itob
    retsub


// smart_contracts.prediction_market.contract.PredictionMarket.get_market_info(market_id: bytes) -> bytes:
get_market_info:
    // smart_contracts/prediction_market/contract.py:77-87
    // @arc4.abimethod(readonly=True)
    // def get_market_info(self, market_id: arc4.UInt64) -> arc4.Tuple[
    //     arc4.String,  # title
    //     arc4.DynamicArray[arc4.String],  # options
    //     arc4.DynamicArray[arc4.UInt64],  # odds
    //     arc4.DynamicArray[arc4.UInt64],  # option_pools
    //     arc4.UInt64,  # total_pool
    //     arc4.UInt64,  # end_time
    //     arc4.UInt64,  # status
    //     arc4.UInt64   # winning_option
    // ]:
    proto 1 1
    // smart_contracts/prediction_market/contract.py:89
    // assert market_id.native <= self.market_counter, "Market does not exist"
    frame_dig -1
    btoi
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    <=
    assert // Market does not exist
    // smart_contracts/prediction_market/contract.py:111
    // arc4.String(self.market_title),
    intc_0 // 0
    bytec_3 // "market_title"
    app_global_get_ex
    assert // check self.market_title exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/prediction_market/contract.py:115
    // arc4.UInt64(self.total_pool),
    intc_0 // 0
    bytec_1 // "total_pool"
    app_global_get_ex
    assert // check self.total_pool exists
    itob
    // smart_contracts/prediction_market/contract.py:116
    // arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    global LatestTimestamp
    pushint 86400 // 86400
    +
    itob
    // smart_contracts/prediction_market/contract.py:110-119
    // return arc4.Tuple((
    //     arc4.String(self.market_title),
    //     options.copy(),
    //     odds.copy(),
    //     option_pools.copy(),
    //     arc4.UInt64(self.total_pool),
    //     arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    //     arc4.UInt64(0),  # status: active
    //     arc4.UInt64(0)   # winning_option: not set
    // ))
    dig 2
    len
    pushint 40 // 40
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0028
    swap
    concat
    swap
    pushint 38 // 38
    +
    dup
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    pushint 26 // 26
    +
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/prediction_market/contract.py:117
    // arc4.UInt64(0),  # status: active
    bytec 5 // 0x0000000000000000
    // smart_contracts/prediction_market/contract.py:110-119
    // return arc4.Tuple((
    //     arc4.String(self.market_title),
    //     options.copy(),
    //     odds.copy(),
    //     option_pools.copy(),
    //     arc4.UInt64(self.total_pool),
    //     arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    //     arc4.UInt64(0),  # status: active
    //     arc4.UInt64(0)   # winning_option: not set
    // ))
    concat
    // smart_contracts/prediction_market/contract.py:118
    // arc4.UInt64(0)   # winning_option: not set
    bytec 5 // 0x0000000000000000
    // smart_contracts/prediction_market/contract.py:110-119
    // return arc4.Tuple((
    //     arc4.String(self.market_title),
    //     options.copy(),
    //     odds.copy(),
    //     option_pools.copy(),
    //     arc4.UInt64(self.total_pool),
    //     arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    //     arc4.UInt64(0),  # status: active
    //     arc4.UInt64(0)   # winning_option: not set
    // ))
    concat
    swap
    concat
    // smart_contracts/prediction_market/contract.py:91-96
    // # Return simplified market info
    // options = arc4.DynamicArray[arc4.String](
    //     arc4.String("Option 1"),
    //     arc4.String("Option 2"),
    //     arc4.String("Option 3")
    // )
    pushbytes 0x000300060010001a00084f7074696f6e203100084f7074696f6e203200084f7074696f6e2033
    // smart_contracts/prediction_market/contract.py:110-119
    // return arc4.Tuple((
    //     arc4.String(self.market_title),
    //     options.copy(),
    //     odds.copy(),
    //     option_pools.copy(),
    //     arc4.UInt64(self.total_pool),
    //     arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    //     arc4.UInt64(0),  # status: active
    //     arc4.UInt64(0)   # winning_option: not set
    // ))
    concat
    // smart_contracts/prediction_market/contract.py:98-102
    // odds = arc4.DynamicArray[arc4.UInt64](
    //     arc4.UInt64(200),
    //     arc4.UInt64(300),
    //     arc4.UInt64(150)
    // )
    pushbytes 0x000300000000000000c8000000000000012c0000000000000096
    // smart_contracts/prediction_market/contract.py:110-119
    // return arc4.Tuple((
    //     arc4.String(self.market_title),
    //     options.copy(),
    //     odds.copy(),
    //     option_pools.copy(),
    //     arc4.UInt64(self.total_pool),
    //     arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    //     arc4.UInt64(0),  # status: active
    //     arc4.UInt64(0)   # winning_option: not set
    // ))
    concat
    // smart_contracts/prediction_market/contract.py:104-108
    // option_pools = arc4.DynamicArray[arc4.UInt64](
    //     arc4.UInt64(0),
    //     arc4.UInt64(0),
    //     arc4.UInt64(0)
    // )
    pushbytes 0x0003000000000000000000000000000000000000000000000000
    // smart_contracts/prediction_market/contract.py:110-119
    // return arc4.Tuple((
    //     arc4.String(self.market_title),
    //     options.copy(),
    //     odds.copy(),
    //     option_pools.copy(),
    //     arc4.UInt64(self.total_pool),
    //     arc4.UInt64(Global.latest_timestamp + UInt64(86400)),  # end_time: 24 hours from now
    //     arc4.UInt64(0),  # status: active
    //     arc4.UInt64(0)   # winning_option: not set
    // ))
    concat
    retsub


// smart_contracts.prediction_market.contract.PredictionMarket.get_user_position(market_id: bytes, user: bytes) -> bytes:
get_user_position:
    // smart_contracts/prediction_market/contract.py:121-126
    // @arc4.abimethod(readonly=True)
    // def get_user_position(self, market_id: arc4.UInt64, user: arc4.Address) -> arc4.Tuple[
    //     arc4.DynamicArray[arc4.UInt64],  # user_bets per option
    //     arc4.UInt64,  # total_bet_amount
    //     arc4.Bool     # is_claimed
    // ]:
    proto 2 1
    // smart_contracts/prediction_market/contract.py:128
    // assert market_id.native <= self.market_counter, "Market does not exist"
    frame_dig -2
    btoi
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    <=
    assert // Market does not exist
    // smart_contracts/prediction_market/contract.py:137-141
    // return arc4.Tuple((
    //     user_bets.copy(),
    //     arc4.UInt64(0),     # total_bet_amount
    //     arc4.Bool(False)    # is_claimed
    // ))
    pushbytes 0x000b0000000000000000000003000000000000000000000000000000000000000000000000
    retsub


// smart_contracts.prediction_market.contract.PredictionMarket.get_market_count() -> bytes:
get_market_count:
    // smart_contracts/prediction_market/contract.py:146
    // return arc4.UInt64(self.market_counter)
    intc_0 // 0
    bytec_0 // "market_counter"
    app_global_get_ex
    assert // check self.market_counter exists
    itob
    retsub
